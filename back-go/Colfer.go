package main

// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf.

import (
	"encoding/binary"
	"fmt"
	"io"
	"math"
)

var intconv = binary.BigEndian

// Colfer configuration attributes
var (
	// ColferSizeMax is the upper limit for serial byte sizes.
	ColferSizeMax = 16 * 1024 * 1024
	// ColferListMax is the upper limit for the number of elements in a list.
	ColferListMax = 64 * 1024
)

// ColferMax signals an upper limit breach.
type ColferMax string

// Error honors the error interface.
func (m ColferMax) Error() string { return string(m) }

// ColferError signals a data mismatch as as a byte index.
type ColferError int

// Error honors the error interface.
func (i ColferError) Error() string {
	return fmt.Sprintf("colfer: unknown header at byte %d", i)
}

// ColferTail signals data continuation as a byte index.
type ColferTail int

// Error honors the error interface.
func (i ColferTail) Error() string {
	return fmt.Sprintf("colfer: data continuation at byte %d", i)
}

type Point struct {
	X float64

	Y float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *Point) MarshalTo(buf []byte) int {
	var i int

	if v := o.X; v != 0 {
		buf[i] = 0
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Y; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is serializer.ColferMax.
func (o *Point) MarshalLen() (int, error) {
	l := 1

	if o.X != 0 {
		l += 9
	}

	if o.Y != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct serializer.Point exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is serializer.ColferMax.
func (o *Point) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, serializer.ColferError and serializer.ColferMax.
func (o *Point) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.X = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Y = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.Point size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, serializer.ColferError, serializer.ColferTail and serializer.ColferMax.
func (o *Point) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type Rect struct {
	MinX float64

	MinY float64

	MaxX float64

	MaxY float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *Rect) MarshalTo(buf []byte) int {
	var i int

	if v := o.MinX; v != 0 {
		buf[i] = 0
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MinY; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MaxX; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.MaxY; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is serializer.ColferMax.
func (o *Rect) MarshalLen() (int, error) {
	l := 1

	if o.MinX != 0 {
		l += 9
	}

	if o.MinY != 0 {
		l += 9
	}

	if o.MaxX != 0 {
		l += 9
	}

	if o.MaxY != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct serializer.Rect exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is serializer.ColferMax.
func (o *Rect) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, serializer.ColferError and serializer.ColferMax.
func (o *Rect) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MinX = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MinY = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MaxX = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.MaxY = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.Rect size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, serializer.ColferError, serializer.ColferTail and serializer.ColferMax.
func (o *Rect) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type SnakeMsg struct {
	Id string

	X float64

	Y float64

	IsBlinking bool

	IsSpeedUp bool

	Length float64

	Scale float64

	FillColor string

	Username string

	Angle float64

	Points []*Point

	CollisionRect *Rect

	Score int64

	Width float64

	Speed float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Points will be replaced with a new value.
func (o *SnakeMsg) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Id); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Id)
	}

	if v := o.X; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Y; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if o.IsBlinking {
		buf[i] = 3
		i++
	}

	if o.IsSpeedUp {
		buf[i] = 4
		i++
	}

	if v := o.Length; v != 0 {
		buf[i] = 5
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Scale; v != 0 {
		buf[i] = 6
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if l := len(o.FillColor); l != 0 {
		buf[i] = 7
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.FillColor)
	}

	if l := len(o.Username); l != 0 {
		buf[i] = 8
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Username)
	}

	if v := o.Angle; v != 0 {
		buf[i] = 9
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if l := len(o.Points); l != 0 {
		buf[i] = 10
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Points {
			if v == nil {
				v = new(Point)
				o.Points[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if v := o.CollisionRect; v != nil {
		buf[i] = 11
		i++
		i += v.MarshalTo(buf[i:])
	}

	if v := o.Score; v != 0 {
		x := uint64(v)
		if v >= 0 {
			buf[i] = 12
		} else {
			x = ^x + 1
			buf[i] = 12 | 0x80
		}
		i++
		for n := 0; x >= 0x80 && n < 8; n++ {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
	}

	if v := o.Width; v != 0 {
		buf[i] = 13
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Speed; v != 0 {
		buf[i] = 14
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is serializer.ColferMax.
func (o *SnakeMsg) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Id); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.SnakeMsg.id exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.X != 0 {
		l += 9
	}

	if o.Y != 0 {
		l += 9
	}

	if o.IsBlinking {
		l++
	}

	if o.IsSpeedUp {
		l++
	}

	if o.Length != 0 {
		l += 9
	}

	if o.Scale != 0 {
		l += 9
	}

	if x := len(o.FillColor); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.SnakeMsg.fillColor exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.Username); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.SnakeMsg.username exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.Angle != 0 {
		l += 9
	}

	if x := len(o.Points); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.SnakeMsg.points exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Points {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.SnakeMsg size exceeds %d bytes", ColferSizeMax))
		}
	}

	if v := o.CollisionRect; v != nil {
		vl, err := v.MarshalLen()
		if err != nil {
			return 0, err
		}
		l += vl + 1
	}

	if v := o.Score; v != 0 {
		l += 2
		x := uint64(v)
		if v < 0 {
			x = ^x + 1
		}
		for n := 0; x >= 0x80 && n < 8; n++ {
			x >>= 7
			l++
		}
	}

	if o.Width != 0 {
		l += 9
	}

	if o.Speed != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct serializer.SnakeMsg exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Points will be replaced with a new value.
// The error return option is serializer.ColferMax.
func (o *SnakeMsg) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, serializer.ColferError and serializer.ColferMax.
func (o *SnakeMsg) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.SnakeMsg.id size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Id = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.X = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Y = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		if i >= len(data) {
			goto eof
		}
		o.IsBlinking = true
		header = data[i]
		i++
	}

	if header == 4 {
		if i >= len(data) {
			goto eof
		}
		o.IsSpeedUp = true
		header = data[i]
		i++
	}

	if header == 5 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Length = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 6 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Scale = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 7 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.SnakeMsg.fillColor size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.FillColor = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 8 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.SnakeMsg.username size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Username = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 9 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Angle = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 10 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.SnakeMsg.points length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*Point, l)
		malloc := make([]Point, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: serializer.SnakeMsg size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Points = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 11 {
		o.CollisionRect = new(Rect)
		n, err := o.CollisionRect.Unmarshal(data[i:])
		if err != nil {
			if err == io.EOF && len(data) >= ColferSizeMax {
				return 0, ColferMax(fmt.Sprintf("colfer: serializer.SnakeMsg size exceeds %d bytes", ColferSizeMax))
			}
			return 0, err
		}
		i += n

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 12 {
		if i+1 >= len(data) {
			i++
			goto eof
		}
		x := uint64(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				b := uint64(data[i])
				i++
				if i >= len(data) {
					goto eof
				}

				if b < 0x80 || shift == 56 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}
		o.Score = int64(x)

		header = data[i]
		i++
	} else if header == 12|0x80 {
		if i+1 >= len(data) {
			i++
			goto eof
		}
		x := uint64(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				b := uint64(data[i])
				i++
				if i >= len(data) {
					goto eof
				}

				if b < 0x80 || shift == 56 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}
		o.Score = int64(^x + 1)

		header = data[i]
		i++
	}

	if header == 13 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Width = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 14 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Speed = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.SnakeMsg size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, serializer.ColferError, serializer.ColferTail and serializer.ColferMax.
func (o *SnakeMsg) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type FoodMsg struct {
	Id string

	X float64

	Y float64

	Width float64

	Height float64
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *FoodMsg) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Id); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Id)
	}

	if v := o.X; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Y; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Width; v != 0 {
		buf[i] = 3
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Height; v != 0 {
		buf[i] = 4
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is serializer.ColferMax.
func (o *FoodMsg) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Id); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.FoodMsg.id exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.X != 0 {
		l += 9
	}

	if o.Y != 0 {
		l += 9
	}

	if o.Width != 0 {
		l += 9
	}

	if o.Height != 0 {
		l += 9
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct serializer.FoodMsg exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is serializer.ColferMax.
func (o *FoodMsg) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, serializer.ColferError and serializer.ColferMax.
func (o *FoodMsg) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.FoodMsg.id size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Id = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.X = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Y = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Width = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 4 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Height = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.FoodMsg size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, serializer.ColferError, serializer.ColferTail and serializer.ColferMax.
func (o *FoodMsg) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type GameUpdateMsg struct {
	Topic string

	Snakes []*SnakeMsg

	Foods []*FoodMsg
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
// All nil entries in o.Snakes will be replaced with a new value.
// All nil entries in o.Foods will be replaced with a new value.
func (o *GameUpdateMsg) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Topic); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Topic)
	}

	if l := len(o.Snakes); l != 0 {
		buf[i] = 1
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Snakes {
			if v == nil {
				v = new(SnakeMsg)
				o.Snakes[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	if l := len(o.Foods); l != 0 {
		buf[i] = 2
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		for vi, v := range o.Foods {
			if v == nil {
				v = new(FoodMsg)
				o.Foods[vi] = v
			}
			i += v.MarshalTo(buf[i:])
		}
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is serializer.ColferMax.
func (o *GameUpdateMsg) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Topic); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.GameUpdateMsg.topic exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if x := len(o.Snakes); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.GameUpdateMsg.snakes exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Snakes {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.GameUpdateMsg size exceeds %d bytes", ColferSizeMax))
		}
	}

	if x := len(o.Foods); x != 0 {
		if x > ColferListMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.GameUpdateMsg.foods exceeds %d elements", ColferListMax))
		}
		for l += 2; x >= 0x80; l++ {
			x >>= 7
		}
		for _, v := range o.Foods {
			if v == nil {
				l++
				continue
			}
			vl, err := v.MarshalLen()
			if err != nil {
				return 0, err
			}
			l += vl
		}
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.GameUpdateMsg size exceeds %d bytes", ColferSizeMax))
		}
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct serializer.GameUpdateMsg exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// All nil entries in o.Snakes will be replaced with a new value.
// All nil entries in o.Foods will be replaced with a new value.
// The error return option is serializer.ColferMax.
func (o *GameUpdateMsg) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, serializer.ColferError and serializer.ColferMax.
func (o *GameUpdateMsg) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.GameUpdateMsg.topic size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Topic = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 1 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.GameUpdateMsg.snakes length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*SnakeMsg, l)
		malloc := make([]SnakeMsg, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: serializer.GameUpdateMsg size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Snakes = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header == 2 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferListMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.GameUpdateMsg.foods length %d exceeds %d elements", x, ColferListMax))
		}

		l := int(x)
		a := make([]*FoodMsg, l)
		malloc := make([]FoodMsg, l)
		for ai := range a {
			v := &malloc[ai]
			a[ai] = v

			n, err := v.Unmarshal(data[i:])
			if err != nil {
				if err == io.EOF && len(data) >= ColferSizeMax {
					return 0, ColferMax(fmt.Sprintf("colfer: serializer.GameUpdateMsg size exceeds %d bytes", ColferSizeMax))
				}
				return 0, err
			}
			i += n
		}
		o.Foods = a

		if i >= len(data) {
			goto eof
		}
		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.GameUpdateMsg size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, serializer.ColferError, serializer.ColferTail and serializer.ColferMax.
func (o *GameUpdateMsg) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}

type IncMsg struct {
	Topic string

	X float64

	Y float64

	Username string
}

// MarshalTo encodes o as Colfer into buf and returns the number of bytes written.
// If the buffer is too small, MarshalTo will panic.
func (o *IncMsg) MarshalTo(buf []byte) int {
	var i int

	if l := len(o.Topic); l != 0 {
		buf[i] = 0
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Topic)
	}

	if v := o.X; v != 0 {
		buf[i] = 1
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if v := o.Y; v != 0 {
		buf[i] = 2
		intconv.PutUint64(buf[i+1:], math.Float64bits(v))
		i += 9
	}

	if l := len(o.Username); l != 0 {
		buf[i] = 3
		i++
		x := uint(l)
		for x >= 0x80 {
			buf[i] = byte(x | 0x80)
			x >>= 7
			i++
		}
		buf[i] = byte(x)
		i++
		i += copy(buf[i:], o.Username)
	}

	buf[i] = 0x7f
	i++
	return i
}

// MarshalLen returns the Colfer serial byte size.
// The error return option is serializer.ColferMax.
func (o *IncMsg) MarshalLen() (int, error) {
	l := 1

	if x := len(o.Topic); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.IncMsg.topic exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if o.X != 0 {
		l += 9
	}

	if o.Y != 0 {
		l += 9
	}

	if x := len(o.Username); x != 0 {
		if x > ColferSizeMax {
			return 0, ColferMax(fmt.Sprintf("colfer: field serializer.IncMsg.username exceeds %d bytes", ColferSizeMax))
		}
		for l += x + 2; x >= 0x80; l++ {
			x >>= 7
		}
	}

	if l > ColferSizeMax {
		return l, ColferMax(fmt.Sprintf("colfer: struct serializer.IncMsg exceeds %d bytes", ColferSizeMax))
	}
	return l, nil
}

// MarshalBinary encodes o as Colfer conform encoding.BinaryMarshaler.
// The error return option is serializer.ColferMax.
func (o *IncMsg) MarshalBinary() (data []byte, err error) {
	l, err := o.MarshalLen()
	if err != nil {
		return nil, err
	}
	data = make([]byte, l)
	o.MarshalTo(data)
	return data, nil
}

// Unmarshal decodes data as Colfer and returns the number of bytes read.
// The error return options are io.EOF, serializer.ColferError and serializer.ColferMax.
func (o *IncMsg) Unmarshal(data []byte) (int, error) {
	if len(data) == 0 {
		return 0, io.EOF
	}
	header := data[0]
	i := 1

	if header == 0 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.IncMsg.topic size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Topic = string(data[start:i])

		header = data[i]
		i++
	}

	if header == 1 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.X = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 2 {
		start := i
		i += 8
		if i >= len(data) {
			goto eof
		}
		o.Y = math.Float64frombits(intconv.Uint64(data[start:]))
		header = data[i]
		i++
	}

	if header == 3 {
		if i >= len(data) {
			goto eof
		}
		x := uint(data[i])
		i++

		if x >= 0x80 {
			x &= 0x7f
			for shift := uint(7); ; shift += 7 {
				if i >= len(data) {
					goto eof
				}
				b := uint(data[i])
				i++

				if b < 0x80 {
					x |= b << shift
					break
				}
				x |= (b & 0x7f) << shift
			}
		}

		if x > uint(ColferSizeMax) {
			return 0, ColferMax(fmt.Sprintf("colfer: serializer.IncMsg.username size %d exceeds %d bytes", x, ColferSizeMax))
		}

		start := i
		i += int(x)
		if i >= len(data) {
			goto eof
		}
		o.Username = string(data[start:i])

		header = data[i]
		i++
	}

	if header != 0x7f {
		return 0, ColferError(i - 1)
	}
	if i < ColferSizeMax {
		return i, nil
	}
eof:
	if i >= ColferSizeMax {
		return 0, ColferMax(fmt.Sprintf("colfer: struct serializer.IncMsg size exceeds %d bytes", ColferSizeMax))
	}
	return 0, io.EOF
}

// UnmarshalBinary decodes data as Colfer conform encoding.BinaryUnmarshaler.
// The error return options are io.EOF, serializer.ColferError, serializer.ColferTail and serializer.ColferMax.
func (o *IncMsg) UnmarshalBinary(data []byte) error {
	i, err := o.Unmarshal(data)
	if i < len(data) && err == nil {
		return ColferTail(i)
	}
	return err
}
