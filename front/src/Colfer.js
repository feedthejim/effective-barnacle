// Code generated by colf(1); DO NOT EDIT.
// The compiler used schema file test.colf for package serializer.


/* eslint-disable */
var serializer = new function () {
	const EOF = 'colfer: EOF';

	function fail(reason) {
		throw new Error(reason);
	}

	// The upper limit for serial byte sizes.
	var colferSizeMax = 16 * 1024 * 1024;
	// The upper limit for the number of elements in a list.
	var colferListMax = 64 * 1024;

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Point = function (init) {

		this.x = 0;

		this.y = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.Point.prototype.marshal = function (buf) {
		if (!buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.x || Number.isNaN(this.x)) {
			buf[i++] = 0;
			view.setFloat64(i, this.x);
			i += 8;
		}

		if (this.y || Number.isNaN(this.y)) {
			buf[i++] = 1;
			view.setFloat64(i, this.y);
			i += 8;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			fail('colfer: serializer.Point serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Point.prototype.unmarshal = function (data) {
		if (!data || !data.length) fail(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function () {
			if (i >= data.length) fail(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function () {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i + pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) fail(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) fail(EOF);
			this.x = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) fail(EOF);
			this.y = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) fail('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			fail('colfer: serializer.Point serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.Rect = function (init) {

		this.minX = 0;

		this.minY = 0;

		this.maxX = 0;

		this.maxY = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.Rect.prototype.marshal = function (buf) {
		if (!buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.minX || Number.isNaN(this.minX)) {
			buf[i++] = 0;
			view.setFloat64(i, this.minX);
			i += 8;
		}

		if (this.minY || Number.isNaN(this.minY)) {
			buf[i++] = 1;
			view.setFloat64(i, this.minY);
			i += 8;
		}

		if (this.maxX || Number.isNaN(this.maxX)) {
			buf[i++] = 2;
			view.setFloat64(i, this.maxX);
			i += 8;
		}

		if (this.maxY || Number.isNaN(this.maxY)) {
			buf[i++] = 3;
			view.setFloat64(i, this.maxY);
			i += 8;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			fail('colfer: serializer.Rect serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.Rect.prototype.unmarshal = function (data) {
		if (!data || !data.length) fail(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function () {
			if (i >= data.length) fail(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function () {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i + pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) fail(EOF);
			}
			return -1;
		}

		if (header == 0) {
			if (i + 8 > data.length) fail(EOF);
			this.minX = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) fail(EOF);
			this.minY = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) fail(EOF);
			this.maxX = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) fail(EOF);
			this.maxY = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) fail('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			fail('colfer: serializer.Rect serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.SnakeMsg = function (init) {

		this.id = '';

		this.x = 0;

		this.y = 0;

		this.isBlinking = false;

		this.isSpeedUp = false;

		this.length = 0;

		this.scale = 0;

		this.fillColor = '';

		this.username = '';

		this.angle = 0;

		this.points = [];

		this.collisionRect = null;

		this.score = 0;

		this.width = 0;

		this.speed = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property points will be replaced with a new serializer.Point.
	this.SnakeMsg.prototype.marshal = function (buf) {
		if (!buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.id) {
			buf[i++] = 0;
			var utf8 = encodeUTF8(this.id);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.x || Number.isNaN(this.x)) {
			buf[i++] = 1;
			view.setFloat64(i, this.x);
			i += 8;
		}

		if (this.y || Number.isNaN(this.y)) {
			buf[i++] = 2;
			view.setFloat64(i, this.y);
			i += 8;
		}

		if (this.isBlinking)
			buf[i++] = 3;

		if (this.isSpeedUp)
			buf[i++] = 4;

		if (this.length || Number.isNaN(this.length)) {
			buf[i++] = 5;
			view.setFloat64(i, this.length);
			i += 8;
		}

		if (this.scale || Number.isNaN(this.scale)) {
			buf[i++] = 6;
			view.setFloat64(i, this.scale);
			i += 8;
		}

		if (this.fillColor) {
			buf[i++] = 7;
			var utf8 = encodeUTF8(this.fillColor);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.username) {
			buf[i++] = 8;
			var utf8 = encodeUTF8(this.username);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.angle || Number.isNaN(this.angle)) {
			buf[i++] = 9;
			view.setFloat64(i, this.angle);
			i += 8;
		}

		if (this.points && this.points.length) {
			var a = this.points;
			if (a.length > colferListMax)
				fail('colfer: serializer.SnakeMsg.points length exceeds colferListMax');
			buf[i++] = 10;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function (v, vi) {
				if (v == null) {
					v = new serializer.Point();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.collisionRect) {
			buf[i++] = 11;
			var b = this.collisionRect.marshal();
			buf.set(b, i);
			i += b.length;
		}

		if (this.score) {
			if (this.score < 0) {
				buf[i++] = 12 | 128;
				if (this.score < Number.MIN_SAFE_INTEGER)
					fail('colfer: serializer/SnakeMsg field score exceeds Number.MIN_SAFE_INTEGER');
				i = encodeVarint(buf, i, -this.score);
			} else {
				buf[i++] = 12;
				if (this.score > Number.MAX_SAFE_INTEGER)
					fail('colfer: serializer/SnakeMsg field score exceeds Number.MAX_SAFE_INTEGER');
				i = encodeVarint(buf, i, this.score);
			}
		}

		if (this.width || Number.isNaN(this.width)) {
			buf[i++] = 13;
			view.setFloat64(i, this.width);
			i += 8;
		}

		if (this.speed || Number.isNaN(this.speed)) {
			buf[i++] = 14;
			view.setFloat64(i, this.speed);
			i += 8;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			fail('colfer: serializer.SnakeMsg serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.SnakeMsg.prototype.unmarshal = function (data) {
		if (!data || !data.length) fail(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function () {
			if (i >= data.length) fail(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function () {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i + pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) fail(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				fail('colfer: serializer.SnakeMsg.id size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				fail('colfer: serializer.SnakeMsg.id size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) fail(EOF);
			this.id = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) fail(EOF);
			this.x = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) fail(EOF);
			this.y = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			this.isBlinking = true;
			readHeader();
		}

		if (header == 4) {
			this.isSpeedUp = true;
			readHeader();
		}

		if (header == 5) {
			if (i + 8 > data.length) fail(EOF);
			this.length = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 6) {
			if (i + 8 > data.length) fail(EOF);
			this.scale = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 7) {
			var size = readVarint();
			if (size < 0)
				fail('colfer: serializer.SnakeMsg.fillColor size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				fail('colfer: serializer.SnakeMsg.fillColor size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) fail(EOF);
			this.fillColor = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 8) {
			var size = readVarint();
			if (size < 0)
				fail('colfer: serializer.SnakeMsg.username size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				fail('colfer: serializer.SnakeMsg.username size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) fail(EOF);
			this.username = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 9) {
			if (i + 8 > data.length) fail(EOF);
			this.angle = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 10) {
			var l = readVarint();
			if (l < 0) fail('colfer: serializer.SnakeMsg.points length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				fail('colfer: serializer.SnakeMsg.points length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new serializer.Point();
				i += o.unmarshal(data.subarray(i));
				this.points[n] = o;
			}
			readHeader();
		}

		if (header == 11) {
			var o = new serializer.Rect();
			i += o.unmarshal(data.subarray(i));
			this.collisionRect = o;
			readHeader();
		}

		if (header == 12) {
			var x = readVarint();
			if (x < 0) fail('colfer: serializer/SnakeMsg field score exceeds Number.MAX_SAFE_INTEGER');
			this.score = x;
			readHeader();
		} else if (header == (12 | 128)) {
			var x = readVarint();
			if (x < 0) fail('colfer: serializer/SnakeMsg field score exceeds Number.MAX_SAFE_INTEGER');
			this.score = -1 * x;
			readHeader();
		}

		if (header == 13) {
			if (i + 8 > data.length) fail(EOF);
			this.width = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 14) {
			if (i + 8 > data.length) fail(EOF);
			this.speed = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) fail('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			fail('colfer: serializer.SnakeMsg serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.FoodMsg = function (init) {

		this.id = '';

		this.x = 0;

		this.y = 0;

		this.width = 0;

		this.height = 0;

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.FoodMsg.prototype.marshal = function (buf) {
		if (!buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.id) {
			buf[i++] = 0;
			var utf8 = encodeUTF8(this.id);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.x || Number.isNaN(this.x)) {
			buf[i++] = 1;
			view.setFloat64(i, this.x);
			i += 8;
		}

		if (this.y || Number.isNaN(this.y)) {
			buf[i++] = 2;
			view.setFloat64(i, this.y);
			i += 8;
		}

		if (this.width || Number.isNaN(this.width)) {
			buf[i++] = 3;
			view.setFloat64(i, this.width);
			i += 8;
		}

		if (this.height || Number.isNaN(this.height)) {
			buf[i++] = 4;
			view.setFloat64(i, this.height);
			i += 8;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			fail('colfer: serializer.FoodMsg serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.FoodMsg.prototype.unmarshal = function (data) {
		if (!data || !data.length) fail(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function () {
			if (i >= data.length) fail(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function () {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i + pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) fail(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				fail('colfer: serializer.FoodMsg.id size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				fail('colfer: serializer.FoodMsg.id size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) fail(EOF);
			this.id = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) fail(EOF);
			this.x = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) fail(EOF);
			this.y = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			if (i + 8 > data.length) fail(EOF);
			this.width = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 4) {
			if (i + 8 > data.length) fail(EOF);
			this.height = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header != 127) fail('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			fail('colfer: serializer.FoodMsg serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.GameUpdateMsg = function (init) {

		this.topic = '';

		this.snakes = [];

		this.foods = [];

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	// All null entries in property snakes will be replaced with a new serializer.SnakeMsg.
	// All null entries in property foods will be replaced with a new serializer.FoodMsg.
	this.GameUpdateMsg.prototype.marshal = function (buf) {
		if (!buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.topic) {
			buf[i++] = 0;
			var utf8 = encodeUTF8(this.topic);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.snakes && this.snakes.length) {
			var a = this.snakes;
			if (a.length > colferListMax)
				fail('colfer: serializer.GameUpdateMsg.snakes length exceeds colferListMax');
			buf[i++] = 1;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function (v, vi) {
				if (v == null) {
					v = new serializer.SnakeMsg();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}

		if (this.foods && this.foods.length) {
			var a = this.foods;
			if (a.length > colferListMax)
				fail('colfer: serializer.GameUpdateMsg.foods length exceeds colferListMax');
			buf[i++] = 2;
			i = encodeVarint(buf, i, a.length);
			a.forEach(function (v, vi) {
				if (v == null) {
					v = new serializer.FoodMsg();
					a[vi] = v;
				}
				var b = v.marshal();
				buf.set(b, i);
				i += b.length;
			});
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			fail('colfer: serializer.GameUpdateMsg serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.GameUpdateMsg.prototype.unmarshal = function (data) {
		if (!data || !data.length) fail(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function () {
			if (i >= data.length) fail(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function () {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i + pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) fail(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				fail('colfer: serializer.GameUpdateMsg.topic size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				fail('colfer: serializer.GameUpdateMsg.topic size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) fail(EOF);
			this.topic = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 1) {
			var l = readVarint();
			if (l < 0) fail('colfer: serializer.GameUpdateMsg.snakes length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				fail('colfer: serializer.GameUpdateMsg.snakes length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new serializer.SnakeMsg();
				i += o.unmarshal(data.subarray(i));
				this.snakes[n] = o;
			}
			readHeader();
		}

		if (header == 2) {
			var l = readVarint();
			if (l < 0) fail('colfer: serializer.GameUpdateMsg.foods length exceeds Number.MAX_SAFE_INTEGER');
			if (l > colferListMax)
				fail('colfer: serializer.GameUpdateMsg.foods length ' + l + ' exceeds ' + colferListMax + ' elements');

			for (var n = 0; n < l; ++n) {
				var o = new serializer.FoodMsg();
				i += o.unmarshal(data.subarray(i));
				this.foods[n] = o;
			}
			readHeader();
		}

		if (header != 127) fail('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			fail('colfer: serializer.GameUpdateMsg serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// Constructor.

	// When init is provided all enumerable properties are merged into the new object a.k.a. shallow cloning.
	this.IncMsg = function (init) {

		this.topic = '';

		this.x = 0;

		this.y = 0;

		this.username = '';

		for (var p in init) this[p] = init[p];
	}

	// Serializes the object into an Uint8Array.
	this.IncMsg.prototype.marshal = function (buf) {
		if (!buf || !buf.length) buf = new Uint8Array(colferSizeMax);
		var i = 0;
		var view = new DataView(buf.buffer);


		if (this.topic) {
			buf[i++] = 0;
			var utf8 = encodeUTF8(this.topic);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}

		if (this.x || Number.isNaN(this.x)) {
			buf[i++] = 1;
			view.setFloat64(i, this.x);
			i += 8;
		}

		if (this.y || Number.isNaN(this.y)) {
			buf[i++] = 2;
			view.setFloat64(i, this.y);
			i += 8;
		}

		if (this.username) {
			buf[i++] = 3;
			var utf8 = encodeUTF8(this.username);
			i = encodeVarint(buf, i, utf8.length);
			buf.set(utf8, i);
			i += utf8.length;
		}


		buf[i++] = 127;
		if (i >= colferSizeMax)
			fail('colfer: serializer.IncMsg serial size ' + size + ' exceeds ' + colferListMax + ' bytes');
		return buf.subarray(0, i);
	}

	// Deserializes the object from an Uint8Array and returns the number of bytes read.
	this.IncMsg.prototype.unmarshal = function (data) {
		if (!data || !data.length) fail(EOF);
		var header = data[0];
		var i = 1;
		var readHeader = function () {
			if (i >= data.length) fail(EOF);
			header = data[i++];
		}

		var view = new DataView(data.buffer, data.byteOffset, data.byteLength);

		var readVarint = function () {
			var pos = 0, result = 0;
			while (pos != 8) {
				var c = data[i + pos];
				result += (c & 127) * Math.pow(128, pos);
				++pos;
				if (c < 128) {
					i += pos;
					if (result > Number.MAX_SAFE_INTEGER) break;
					return result;
				}
				if (pos == data.length) fail(EOF);
			}
			return -1;
		}

		if (header == 0) {
			var size = readVarint();
			if (size < 0)
				fail('colfer: serializer.IncMsg.topic size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				fail('colfer: serializer.IncMsg.topic size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) fail(EOF);
			this.topic = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header == 1) {
			if (i + 8 > data.length) fail(EOF);
			this.x = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 2) {
			if (i + 8 > data.length) fail(EOF);
			this.y = view.getFloat64(i);
			i += 8;
			readHeader();
		}

		if (header == 3) {
			var size = readVarint();
			if (size < 0)
				fail('colfer: serializer.IncMsg.username size exceeds Number.MAX_SAFE_INTEGER');
			else if (size > colferSizeMax)
				fail('colfer: serializer.IncMsg.username size ' + size + ' exceeds ' + colferSizeMax + ' UTF-8 bytes');

			var start = i;
			i += size;
			if (i > data.length) fail(EOF);
			this.username = decodeUTF8(data.subarray(start, i));
			readHeader();
		}

		if (header != 127) fail('colfer: unknown header at byte ' + (i - 1));
		if (i > colferSizeMax)
			fail('colfer: serializer.IncMsg serial size ' + size + ' exceeds ' + colferSizeMax + ' bytes');
		return i;
	}

	// private section

	var encodeVarint = function (bytes, i, x) {
		while (x > 127) {
			bytes[i++] = (x & 127) | 128;
			x /= 128;
		}
		bytes[i++] = x & 127;
		return i;
	}

	var encodeUTF8 = function (s) {
		var i = 0;
		var bytes = new Uint8Array(s.length * 3);
		for (var ci = 0; ci != s.length; ci++) {
			var c = s.charCodeAt(ci);
			if (c < 128) {
				bytes[i++] = c;
				continue;
			}
			if (c < 2048) {
				bytes[i++] = c >> 6 | 192;
			} else {
				if (c > 0xd7ff && c < 0xdc00) {
					if (++ci == s.length) {
						bytes[i++] = 63;
						continue;
					}
					var c2 = s.charCodeAt(ci);
					if (c2 < 0xdc00 || c2 > 0xdfff) {
						bytes[i++] = 63;
						--ci;
						continue;
					}
					c = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
					bytes[i++] = c >> 18 | 240;
					bytes[i++] = c >> 12 & 63 | 128;
				} else bytes[i++] = c >> 12 | 224;
				bytes[i++] = c >> 6 & 63 | 128;
			}
			bytes[i++] = c & 63 | 128;
		}
		return bytes.subarray(0, i);
	}

	var decodeUTF8 = function (bytes) {
		var s = '';
		var i = 0;
		while (i < bytes.length) {
			var c = bytes[i++];
			if (c > 127) {
				if (c > 191 && c < 224) {
					c = (i >= bytes.length) ? 63 : (c & 31) << 6 | bytes[i++] & 63;
				} else if (c > 223 && c < 240) {
					c = (i + 1 >= bytes.length) ? 63 : (c & 15) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
				} else if (c > 239 && c < 248) {
					c = (i + 2 >= bytes.length) ? 63 : (c & 7) << 18 | (bytes[i++] & 63) << 12 | (bytes[i++] & 63) << 6 | bytes[i++] & 63;
				} else c = 63;
			}

			if (c <= 0xffff) s += String.fromCharCode(c);
			else if (c > 0x10ffff) s += '?';
			else {
				c -= 0x10000;
				s += String.fromCharCode(c >> 10 | 0xd800)
				s += String.fromCharCode(c & 0x3FF | 0xdc00)
			}
		}
		return s;
	}
}

// NodeJS:
if (typeof exports !== 'undefined') exports.serializer = serializer;
